

# X = np.random.multivariate_normal(mean, covariance, size = 1000)
# Y = np.array([get_adversary_reward("logistic", x, w_star) for x in X])

# Sample some(say, 50) data points in the beginning
# for i in range(t):
# 	y = get_adversary_reward("logistic", X[0], w_star)
# 	dataset["ip"].append(x)
# 	dataset["op"].append(y)






# Estimate an initial w_hat using the above sampled data points
# estimator = Estimator(dataset)
# w_hat = np.random.multivariate_normal(mean, covariance, size = 1)[0]
# w_hat = estimator.estimate("Gradient Descent", w_hat, D)			# Estimate w_hat using gradient descent
# epsilon = np.linalg.norm(w_star - w_hat)
# print "Distance = ", epsilon
# y_plot.append(epsilon)
# x_plot.append(i - 1)

# print "lengths = ", len(estimator.dataset["ip"]), len(dataset["ip"])

# for i in range(50, 1000):
# 	print "Doing ", i
# 	x = np.random.multivariate_normal(mean, covariance, size = 1)[0]
# 	y = get_adversary_reward("logistic", x, w_star)
# 	X1 = list(X)
# 	Y1 = list(Y)
# 	X1.append(x)
# 	Y1.append(y)
# 	X = np.array(X1)
# 	Y = np.array(Y1)
# 	model.fit(X,Y)
# 	w_hat = model.coef_
# 	epsilon = np.linalg.norm(w_star - w_hat)
# 	print "Distance = ", epsilon
# 	y_plot.append(epsilon)
# 	x_plot.append(i)
# 	estimator.dataset["ip"].append(x)
# 	estimator.dataset["op"].append(y)
# 	# print "New length = ", len(estimator.dataset["ip"])
# 	w_hat = estimator.estimate("Gradient Descent", w_hat, D)
# 	epsilon = np.linalg.norm(w_star - w_hat)
# 	# print "Distance = ", epsilon
# 	y_plot.append(epsilon)
# 	x_plot.append(i)





# def acquisition(i, ro):
# 	mu = helper.get_link_val("logistic", X[i], w_hat)
# 	explore = ro * np.dot(np.dot(X[i], M_inv), X[i].transpose())
#
# 	return mu + explore

# def get_best_arm(ro):
# 	max = acquisition(0, ro)
# 	mi = 0
# 	for i in range(1, 1000):
# 		score = acquisition(i, ro)
# 		if(max < score):
# 			max = score
# 			mi = i
#
# 	return mi




# def get_link_val(link, *argv):
# 	p = helper.link_func(link, *argv)
# 	return p
# print p
# return bernoulli.rvs(p)	# + np.random.normal(0, 1, 1)[0]






# def get_adversary_reward(link, *argv):
# 	argv.append(w_star)
# 	return helper.link_func(link, *argv)


# add = np.outer(X[j], X[j].transpose())
# M = M + add
# M_inv = update_mat_inv(M_inv, add)


# epsilon = np.linalg.norm(w_star - w_hat)
# print "Distance = ", epsilon
# y_plot.append(epsilon)
# x_plot.append(49)






# TO BE INCORPORATED LATER
'''
while (eplsilon >= threshold and t < 100000):
	global epsilon, t
	x = choose_arm()
	y = get_adversary_reward("logistic", x, w_star)
	estimator.dataset["ip"].append(x)
	estimator.dataset["op"].append(y)
	w_hat = estimator.estimate("Gradient Descent")
	epsilon = np.linalg.norm(w_star - w_hat)
	t += 1
	yplot.append(epsilon)
	xplot.append(t)

'''





















HELPER BACK UP






'''
   FUNCTION TO GENERATE DATASET FOR THE ADVERSARY

   ARGUMENTS: NONE

   RETURNS: DICT
	Dataset, which is a dictionary with input point as key and output as value

def simulate_data():
	# Fix a w_star
	mean = np.zeros(1000)
	covariance = np.random.rand(1000, 1000)
	w_star = np.random.multivariate_normal(mean, covariance, size = 1)[0]

	dataset = {}
	for i in range(10000):
		while (True):
			x = np.random.multivariate_normal(mean, covariance, size = 1)[0]		# Pick an input
			if (x not in dataset):
				y = link_func("logistic", x, w_star) + np.random.normal(0, 1, 1)[0]             # Generate it's output
				dataset[x] = y
				break

	return dataset, w_star
'''
